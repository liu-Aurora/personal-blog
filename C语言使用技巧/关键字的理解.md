# 关键字的理解

> 内存分配：
>
> 1、栈区：局部变量、函数参数
>
> 2、堆区：动态内存管理
>
> 3、静态区：全局变量、静态变量、常量

## 一、static理解

> **static 一般用于修饰局部变量，全局变量，函数；**

**1. static（静态的）修饰局部变量**

>static修饰局部变量时，静态局部变量存储于进程中的全局数据区，本质上改变了局部变量的存储位置，生命周期变长，为整个周期。

```text
//实例解释

#include<stdio.h>

void test()
{
	int a = 1;
	a++;
	printf("%d   ", a);
}

int main(void)
{
	int i = 0;
	while (i <= 10)
	{
		test();
		i++;
	}
	return 0;
}

//此时结果为2 2 2 2 2 2 2 2 2 2 
//将int a=1;  --------------  改为static int a=1; 后:
//a被static修饰，变成全局变量，生命周期变强。  ---------------- 结果为2 3 4 5 6 7 8 9 10
```

**2. static（静态的）修饰全局变量**

> 全局变量的属性：全局变量具有外部链接属性，通过extern关键字，可以使全局变量再其他.c文件中运用。而static修饰全局变量时，这个全局变量的外部链接属性变为内部链接属性，其他.c文件不能使用。

**3. static（静态的）修饰函数**

> 函数同样具有外部属性。而static修饰函数时，这个函数的外部链接属性变为内部链接属性，是其他源文件（.c）文件就可以再使用这个函数了。则使用时我们会感觉到该函数作用域变小。

**当static修饰全局变量和函数时**：是将全局变量和函数的作用域变小了，其他.c文件不能调用，保护了全局变和函数的安全

## 二、extern（外部）理解

> extern是关于声明的关键字，变量的声明有两种情况：
>
> 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
>
> 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。

> **在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern修饰变量的声明， extern修饰函数声明**

## 三、const（常量）理解

**1. const修饰普通变量**

> 用const修饰普通变量实际上就是**定义了一个常量**，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是**不可变的**，**不可被修改**。 一般对于**const变量名都是全大写的**。

```text
TYPE const ValueName = value; 
 
const TYPE ValueName = value;
```

> 实际上，虽然不能直接对常变量进行修改，但是我们可以通过指针对常变量进行修改
>
>所以当指针指向const常变量时，为避免通过指针修改const常变量，我们应当相应地用const指针指向const常变量。

```text
const int AMOUNT = 100；
int const *p = &AMOUNT；
```

>**用const定义的常量有什么作用呢？**
>
>假设我们在代码中经常使用到一个数字100，我们可以定义一个常量，让常量的值100：
>
>` const int AMOUNT = 100;`
>
>如果我们没定义常量，我们需要将100修改为200，需要将代码出现的所有100依次修改为200，而如果我们定义了常量，我们只需要修改常变量的值为200即可，这样就增加了代码的可维护性。
>
> 
>
>如果将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义。
>
>`extend const int ValueName = value;`

**2. const修饰指针**

**const修饰p**：**p代表是指针，指向的是地址，不可改变的是地址**

> const修饰指针p表示指针不可修改，即一旦得到了某个变量的地址，不能再指向其它变量：

```text
int i = 10;
int * const p = &i;
p++;//p指针指向下一个元素，错误
```

> 虽然指针不可修改，但是可以修改指针所指向的变量的值：

```cpp
int i = 10;
int * const p = &i;
*p = 26;//没问题
```

 **const修饰\*p：*p代表的数值，\*p指向的数值  **

> const修饰*p表示不可通过指针修改其所指变量的值：

```text 
int i = 10;
const int* p = &i;
*p = 26;//通过指针修改其所指变量的值,错误
```

> 虽然不可以通过指针修改指针所指变量的值，但是变量i本身可以做任何变化，如：

```text
int i = 10;
const int* p = &i;
i=26;
i++;
```

**const修饰p和\*p**

> const修饰p和*p表示指针不能变，指针所指的变量也不能变。

`const int* const p;`

**3.const修饰数组**

> 数组变量实际上就是const的指针，所以不能直接赋值:

```text
int a[]
//a--->int* const a;
```

> a本身是指针，用const进行修饰，a地址不能被修改，可以进行赋值

> const修饰数组表明数组的每个元素都是const int，无法修改，所以必须通过初始化进行赋值，否则写出来后就无法进行赋值了。

```text
const int a[]
//a---->const int * const a;
```

****

**4.const修饰函数形参**

 **const修饰普通形参变量**

`void function(const int Var);`

> 这表示形参不会发生改变，但实际上这是没有意义的，因为我们通常是为了保证外部的实参数据不发生变化，这里形参实际上是实参的拷贝，实参本来就不会发生变化。

 **const修饰指针形参**

`void function(const char* Var);`

> 我们把外部实参的地址赋值给用const修饰的指针形参，这样我们就无法通过指针修改其所指的外部实参，保护了数据的安全性。
>
> 但如果是这种const指针形参就毫无意义：

`void function(char* const Var);`

 **const修饰引用形参**

`void function(const Type& Var); //引用参数在函数内不可以改变`

>参数为引用，将外部实参传递给引用形参，传递的是外部实参本身，无需进行拷贝，增加了效率，同时参数是const引用，无法通过引用修改实参，保证了外部数据的安全性。