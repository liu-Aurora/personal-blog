# 任务调度与时间片调度

## 一、**开启任务调度器**

`vTaskStartScheduler() `

>作用：用于启动任务调度器，任务调度器启动后， FreeRTOS 便会开始进行任务调度 

**函数内部实现**：

1. 创建空闲任务

2. 如果使能软件定时器，则创建定时器任务

3. 关闭中断，防止调度器开启之前或过程中，受中断干扰，会在运行第一个任务时打开中断

4. 初始化全局变量，并将任务调度器的运行标志设置为已运行

5. 初始化任务运行时间统计功能的时基定时器

6. 调用函数 xPortStartScheduler()

```text
void vTaskStartScheduler( void )
{
	BaseType_t xReturn;

	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
	
		//静态创建空闲任务 --任务句柄，栈指针，控制块内存,栈大小（自己分配任务栈堆空间）
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
		StackType_t *pxIdleTaskStackBuffer = NULL;
		uint32_t ulIdleTaskStackSize;
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
		//静态创建任务，返回句柄
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
												configIDLE_TASK_NAME,
												ulIdleTaskStackSize,
												( void * ) NULL, 
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer );
		//判断是否成功
		if( xIdleTaskHandle != NULL )
		{
			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
		}
	}
	#else
	{
		
		xReturn = xTaskCreate(	prvIdleTask,
								configIDLE_TASK_NAME,
								configMINIMAL_STACK_SIZE,
								( void * ) NULL,
								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
								&xIdleTaskHandle );
	}
	
	//如果使能软件定时器，则创建定时器任务
    #if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	if( xReturn == pdPASS )
	{
		//关闭中断，防止调度器开启之前或过程中，受中断干扰，会在运行第一个任务时打开中断
		portDISABLE_INTERRUPTS();

		//阻塞任务，唤醒时间，没有阻塞任务，设置成最大值portMAX_DELAY
		xNextTaskUnblockTime = portMAX_DELAY;
		
		//初始化全局变量，并将任务调度器的运行标志设置为已运行，滴答定时器设置成0
		xSchedulerRunning = pdTRUE;
		xTickCount = ( TickType_t ) 0U;
		if( xPortStartScheduler() != pdFALSE )
		{
			
		}
	}
}
```





`xPortStartScheduler()`

>作用：该函数用于完成启动任务调度器中与硬件架构相关的配置部分，以及启动第一个任务

**函数内部实现**

1. 检测用户在 FreeRTOSConfig.h 文件中对中断的相关配置是否有误

2. 配置 PendSV 和 SysTick 的中断优先级为最低优先级

3. 调用函数 vPortSetupTimerInterrupt()配置 SysTick

4. 初始化临界区嵌套计数器为 0

5. 调用函数 prvEnableVFP()使能 FPU

6. 调用函数 prvStartFirstTask()启动第一个任务

```text
BaseType_t xPortStartScheduler( void )
{
	#if( configASSERT_DEFINED == 1 )
	{
		.................................
		.................................
		
		//检测用户在 FreeRTOSConfig.h 文件中对中断的相关配置是否有误
		
		.................................
		.................................
		
		//配置 PendSV 和 SysTick 的中断优先级为最低优先级15
		portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
		portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
		
	}
		//配置SysTick
		vPortSetupTimerInterrupt();
		
		//初始化临界区嵌套计数器为 0
		uxCriticalNesting = 0;
		
		//用函数 prvStartFirstTask()启动第一个任务
		prvStartFirstTask();

		return 0;
}

//配置SysTick
#if( configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0 )

	void vPortSetupTimerInterrupt( void )
	{
		.......................................
		.......................................
		
		
		portNVIC_SYSTICK_CTRL_REG = 0UL;
		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
		
		//设置重装载值
		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
		//配置中断请求，和滴答定时器的时钟源 --- 保证滴答定时器1ms中断有一次
		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | 						portNVIC_SYSTICK_ENABLE_BIT );
	}

#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
```



## 二、启动第一个任务

**如何启动第一个任务？**

>假设我们要启动的第一个任务是任务A，那么就需要将任务A的寄存器值恢复到CPU寄存器
>
>任务A的寄存器值，在一开始创建任务时就保存在任务堆栈里边！

**注意**

>1、中断产生时，硬件自动将xPSR，PC(R15)，LR(R14)，R12，R3-R0出/入栈；而R4~R11需要手动出/入栈
>
>2、进入中断后硬件会强制使用MSP指针 ，此时LR(R14）的值将会被自动被更新为特殊的EXC_RETURN

**prvStartFirstTask ()  该函数用于初始化启动第一个任务前的环境，主要是重新 设置MSP 指针，并使能全局中断**

>什么是MSP指针？
>
>主堆栈指针（MSP）：它由 OS 内核、异常服务例程以及所有需要特权访问的应用程 序代码来使用。 
>
>进程堆栈指针（PSP）：用于常规的应用程序代码（不处于异常服用例程中时）。 
>
>注意：在FreeRTOS中，中断使用MSP（主堆栈），中断以外使用PSP（进程堆栈）

>为什么是 0xE000ED08？ 
>
>因为需从 0xE000ED08 获取向量表的偏移，为啥要获得向量表呢？因为向量表的第一个是 MSP 指针！
>
>取 MSP 的初始值的思路是先根据向量表的位置寄存器 VTOR (0xE000ED08) 来获取向量表存储的地址；
>
>在根据向量表存储的地址，来访问第一个元素，也就是初始的 MSP
>
>CM3 允许向量表重定位——从其它地址处开始定位各异常向量 这个就是向量表偏移量寄存器，向量表的起始地址保存的就是主栈指针MSP 的初始值

## 三、SVC中断服务函数

`vPortSVCHandler () `

>**当使能了全局中断，并且手动触发 SVC 中断后，就会进入到 SVC 的中断服务函数中**
>
>**注意：SVC中断只在启动第一次任务时会调用一次，以后均不调用**  
>
>1. 通过 pxCurrentTCB 获取优先级最高的就绪态任务的任务栈地址，优先级最高的就绪态任务是系统将要运行的任务 。
>
>2. 通过任务的栈顶指针，将任务栈中的内容出栈到 CPU 寄存器中，任务栈中的内容在调用任务创建函数的时候，已初始化，然后设置 PSP 指针 。
>
>3. 通过往 BASEPRI 寄存器中写 0，允许中断。
>
>4. 执行 bx R14，告诉处理器 ISR 完成，需要返回，此刻处理器便会使用 PSP 做为堆栈指针，进行出栈操作，将xPSR、PC、LR、R12、R3~R0 出栈，初始化的时候，PC 被我们赋值成为了执行任务的函数的入口，所以呢，就正常跳入到了优先级最高的就緒 状态的第一个任务的入口函数了

## 四、任务切换流程

**触发PendSV中断，主要途径**：

- 滴答定时器中断触发
- 调用FreeRTOS的API函数触发，如：portYIELD( 

 **PendSV中断函数触发，执行任务切换**

 >1. 当前的psp是正在运行的任务的栈指针，读取当前psp进程指针，存入r0
 >2. 压栈（保存现场）
 >3. 获取当前最高优先级任务的任务控制块
 >4. 出栈（恢复现场）
 >5. 更新切换后的任务的的栈指针给PSP
 >6. bx r14 执行新任务函数

**任务切换的本质**：就是CPU寄存器的切换。

假设当由任务**A切换到任务B时，主要分为两步：**

> 第一步：需暂停任务A的执行，并将此时任务A的寄存器保存到任务堆栈，这个过程叫 做保存现场；
>
> 第二步：将任务B的各个寄存器值（被存于任务堆栈中）恢复到CPU寄存器中，这个过 程叫做恢复现场;
>
> 对任务A保存现场，对任务B恢复现场，这个整体的过程称之为：上下文切换

**通过函数vTaskSwitchContext（）查找最高优先级任务**

>利用函数taskSELECT_HIGHEST_PRIORITY_TASK( )，前导置零指令找到最高优先级
>
>利用函数listGET_OWNER_OF_NEXT_ENTRY( ），获取最高优先级的任务句柄

## 五、时间片调度

>抢占式调度：主要是针对优先级不同的任务，每个任务都有一个优先级，优先级高的任务可以抢占优先级低的任务。
>
>时间片调度：主要针对优先级相同的任务，当多个任务的优先级相同时， 任务调度器会在每一次系统时钟节拍到的时候切换任务。

**时间片调度：同等优先级任务轮流地享有相同的CPU时间，叫时间片，在FreeRTOS中，一个时间片就等于SysTick中断周期。**

>1. 同等优先级任务，轮流执行，时间片流转
>2. 一个时间片大小，取决为滴答定时器中断频率
>3. 注意没有用完的时间片不会再使用，下次任务执行还是按照一个时间片的时钟节拍运行