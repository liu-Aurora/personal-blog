# 信号量

> 信号量的简介：信号量是一种解决同步问题的机制，可以实现对共享资源的有序访问
>
> 同定义全局变量，也可以实现同步问题的机制
>
> 全局变量与信号量的优缺点：

## 一、信号量的简介

<img src="C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240808222219101.png" alt="image-20240808222219101" style="zoom:80%;" />	

**当计数值大于0，代表有信号量资源**

>当释放信号量，信号量计数值（资源数）加一
>
>当获取信号量，信号量计数值（资源数）减一

**信号量的计数值都有限制：限定最大值**

>如果最大值被限定为1，那么它就是二值信号量；
>
>如果最大值不是1，它就是计数型信号量

---

## 二、**队列与信号量的对比** 

<img src="C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240808222413794.png" alt="image-20240808222413794" style="zoom:80%;" />	

---

## 三、二值信号量

**简介：二值信号量的本质是一个队列长度为 1 的队列 ，该队列就只有空和满两种情况，这就是二值。**

>二值信号量通常用于互斥访问或任务同步， 与互斥信号量比较类似，但是二值信号量有可能会导致优先级翻转的问题 ，所以二值信号量更适合用于同步！

![image-20240808222752357](C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240808222752357.png)

> **使用二值信号量的过程：创建二值信号量>释放二值信号量>获取二值信号量**  

### 1、创建二值信号量函数

`SemaphoreHandle_t  xSemaphoreCreateBinary( void ) `

```c
#define   xSemaphoreCreateBinary( )   					
 		  ueueGenericCreate( 1 , semSEMAPHORE_QUEUE_ITEM_LENGTH , queueQUEUE_TYPE_BINARY_SEMAPHORE )
              
#define  semSEMAPHORE_QUEUE_ITEM_LENGTH      ( ( uint8_t ) 0U )
```

```c
#define queueQUEUE_TYPE_BASE                  			( ( uint8_t ) 0U )	/* 队列 */
#define queueQUEUE_TYPE_SET                  			( ( uint8_t ) 0U )	/* 队列集 */
#define queueQUEUE_TYPE_MUTEX                 			( ( uint8_t ) 1U )	/* 互斥信号量 */
#define queueQUEUE_TYPE_COUNTING_SEMAPHORE    			( ( uint8_t ) 2U )	/* 计数型信号量 */
#define queueQUEUE_TYPE_BINARY_SEMAPHORE     			( ( uint8_t ) 3U )	/* 二值信号量 */
#define queueQUEUE_TYPE_RECURSIVE_MUTEX       			( ( uint8_t ) 4U )	/* 递归互斥信号量 
```

### 2、释放二值信号量函数

`BaseType_t  xSemaphoreGive( xSemaphore ) `

```c
define  xSemaphoreGive (  xSemaphore  )    						
		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL , semGIVE_BLOCK_TIME , queueSEND_TO_BACK )
```

### 3、获取二值信号量

`BaseType_t  xSemaphoreTake( xSemaphore, xBlockTime ) `

---

## 四、计数型信号量

>计数型信号量相当于队列长度大于1 的队列，因此计数型信号量能够容纳多个资源，这在计数型信号量被创建的时候确定的

**计数型信号量适用场合**

>**事件计数：**
>
>当每次事件发生后，在事件处理函数中释放计数型信号量（计数值+1），其他任务会获取计数型信号量（计数值-1） ，这种场合一般在创建时将初始计数值设置为 0 
>
>**资源管理：**
>
>信号量表示有效的资源数目。任务必须先获取信号量（信号量计数值-1 ）才能获取资源控制权。当计数值减为零时表示没有的资源。当任务使用完资源后，必须释放信号量（信号量计数值+1）。信号量创建时计数值应等于最大资源数目

> **使用计数型信号量的过程：创建计数型信号量>释放信号量>获取信号量**

### 1、**创建计数型信号量**

`xSemaphoreCreateCounting()`

```c
#define 	xSemaphoreCreateCounting(  uxMaxCount  ,  uxInitialCount  )   												xQueueCreateCountingSemaphore( (  uxMaxCount  ) , (  uxInitialCount  ) ) 
```

>此函数用于创建一个计数型信号量 
>
>- uxMaxCount                 ---计数值的最大值限定
>- uxInitialCount               ---计数值的初始值

### 2、获取信号量当前计数值大小

`uxSemaphoreGetCount()`

```c
#define 	uxSemaphoreGetCount( xSemaphore ) 							
			uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
```

>此函数用于获取信号量当前计数值大小
>
>- xSemaphore                 ---信号量句柄

---

## 五、**优先级翻转**

>优先级翻转：高优先级的任务反而慢执行，低优先级的任务反而优先执行
>
>优先级翻转在抢占式内核中是非常常见的，但是在实时操作系统中是不允许出现优先级翻转的，因为优先级翻转会破坏任务的预期顺序，可能会导致未知的严重后果。
>
>**在使用二值信号量的时候，经常会遇到优先级翻转的问题。**

<img src="C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240808224835700.png" alt="image-20240808224835700" style="zoom: 67%;" />	

>高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他**中等优先级的任务却能抢到CPU资源**。从现象上看，就像是**中优先级的任务比高优先级任务具有更高的优先权**（即**优先级翻转**）

## 六、**互斥信号量**

>简介：
>
>互斥信号量其实就是一个**拥有优先级继承的二值信号量**，在**同步的应用中二值信 号量最适合**。**互斥信号量适合用于那些需要互斥访问的应用中**！

**优先级继承并不能完全的消除优先级翻转的问题，它只是尽可能的降低优先级翻转带来的影响**

互斥信号量**不能用于中断服务函数**中，原因如下：

>(1) 互斥信号量有任务优先级继承的机制， 但是中断不是任务，没有任务优先级， 所以互斥信号量只能用与任务中，不能用于中断服务函数。
>
>(2) 中断服务函数中不能因为要等待互斥信号量而设置阻塞时间进入阻塞态。

<img src="C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240808225629990.png" alt="image-20240808225629990" style="zoom:67%;" />	

>优先级继承：当一个互斥信号量正在被一个低优先级的任务持有时， 如果此时有个高优先级的任务也尝试获取这个互斥信号量，那么这个高优先级的任务就会被阻塞。**不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级。**

**使用流程：创建互斥信号量 >（task）获取信号量 >（give）释放信号量**

### 1、创建互斥信号量函数：

**动态方法创建互斥信号量**

`xSemaphoreCreateMutex()`

```c
#define   xSemaphoreCreateMutex()      xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
```

>互斥信号量的释放和获取函数与二值信号量相同 ！只不过互斥信号量不支持中断中调用
>
>注意：创建互斥信号量时，会主动释放一次信号量