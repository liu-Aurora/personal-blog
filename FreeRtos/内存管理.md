# 内存管理

## 一、stm32的内存架构

### 1、stm32的内存类型

- Flash（闪存）：用于存储程序代码和只读数据，例如**固件、常量**等。FLASH 具有非易失性，即**使断电后数据也不会丢失**。
- SRAM（静态随机存取存储器）：用于存储程序运行时的**变量、堆栈**等数据。SRAM 具有易失性，**断电后数据会丢失**。
- 其他内存：EEPROM (**电可擦除可编程只读存储器**) 等其他类型的内存，用于存储一些需要掉电保存的参数。

### 2、内存分配

>STM32 的内存分配通常由**链接器脚本 (Linker Script) 控制**，链接器脚本描述了代码和数据在内存中的布局。

* **FLASH 分配:**
    * **代码段 (Text Segment):** 存储程序的机器指令。
    * **只读数据段 (RO-Data Segment):** 存储常量和字符串字面量。
* **SRAM 分配:**
    * **数据段 (Data Segment):** 存储初始化的全局变量和静态变量。
    * **BSS 段 (Block Started by Symbol Segment):** 存储未初始化的全局变量和静态变量。
    * **堆 (Heap):** 用于动态内存分配，由 `malloc()`、`free()` 等函数管理。
    * **栈 (Stack):** 用于存储函数调用时的局部变量、参数和返回地址。

### 3、具体存储内容

* **FLASH 存储内容：**
    * 应用程序代码 (Firmware)
    * 常量，例如字符串字面量、数值常量等
    * 只读数据，例如查找表、配置文件等
* **SRAM 存储内容：**
    * 全局变量和静态变量
    * 函数的局部变量
    * 函数的参数和返回值
    * FreeRTOS 的任务控制块 (TCB)
    * FreeRTOS 的堆
    * 中断处理程序使用的临时变量

---

## 二、堆和静态区（区别）

**为什么要有堆？**

> **举例情况：**
>
> 假设你正在编写一个程序来处理用户输入的文本。你不知道用户将输入多少文本，因此无法在编译时为文本分配固定的内存空间。这时，你可以使用堆来动态分配内存。当用户输入文本时，程序可以根据需要从堆中申请内存来存储文本。当文本不再需要时，程序可以将内存释放回堆，以便其他部分程序使用。
>
> - **动态内存分配:**堆允许程序在运行时根据实际需要申请内存空间，从而更加灵活地处理数据
> - **数据结构的灵活性**：许多数据结构，如链表、树和图，需要动态地增长和缩减，使用堆可以根据需要分配和释放内存，从而有效地管理这些动态数据结构。
> -  **提高内存利用率：**静态分配内存可能会导致内存浪费，因为程序可能并不总是需要所有分配的内存。堆允许程序只在需要时分配内存，并在不需要时释放内存，从而提高内存利用率。
>
> **总结：**堆的存在使得程序能够在运行时动态地分配和释放内存，从而更加灵活地处理数据，提高内存利用率，并增强代码的可重用性和可维护性。

---

**静态区 (Static memory area):**

* **用途:** 存储程序运行期间一直存在的变量，包括全局变量和静态变量。
* **分配方式:** 在**程序编译时**就**分配好内存空间**，大小**固定**。
* **生命周期:** 整个程序运行期间都存在，直到**程序结束才释放**。
* **管理方式:** 由编译器和链接器管理，程序员无需手动分配和释放。

**堆 (Heap):**

* **用途:**  存储程序运行期间动态分配的内存。
* **分配方式:**  在**程序运行时**根据需要**动态分配内存空间，大小可变**。
* **生命周期:**  从分配开始，到**手动释放或程序结束为止**。
* **管理方式:**  由程序员通过内存管理函数 (如 `malloc()`, `free()`, `pvPortMalloc()`, `vPortFree()` ) 手动分配和释放。

**堆和静态区的关键区别：**

| 特性     | 静态区           | 堆           |
| -------- | ---------------- | ------------ |
| 分配时机 | 编译时           | 运行时       |
| 空间大小 | 固定             | 可变         |
| 生命周期 | 整个程序运行期间 | 从分配到释放 |
| 管理方式 | 编译器/链接器    | 程序员       |

---

## 三、FreeRTOS的内存管理

> * FreeRTOS 的堆管理机制是建立在静态分配的数组之上的，它将这个数组划分成小块，并通过特定的算法来管理这些小块的分配和释放。 静态区本身并不具备动态内存分配和释放的能力，FreeRTOS 的堆管理器只是利用了静态区中预留的内存空间来实现自己的堆管理功能

>为什么FreeRTOS的堆空间是从静态区分配的，但它具备动态内存分配和释放的能力，静态区在程序编译时就分配好内存空间，大小固定。
>
>>FreeRTOS 的堆管理机制实际上是一种 “伪动态”  的内存管理方式，它本身并没有真正意义上的动态内存分配能力。。它巧妙地利用了静态分配的内存块，实现了在有限资源下进行动态内存管理的功能。
>>
>>- **内存池的创建 (静态分配)：**在启动 FreeRTOS 的时候，会从静态区预留一块固定大小的内存，这就是我们的 “内存池”。 这块内存的大小由 `configTOTAL_HEAP_SIZE`  定义。
>>- **内存池的划分:** FreeRTOS 的堆管理器会将这个 “内存池” 划分成若干个大小不同的小块。
>>- **动态分配的实现:** 当需要为任务堆栈或其他动态内存需求分配内存时，FreeRTOS 的堆管理器会在 “内存池” 中寻找一块足够大的空闲块。如果找到，就将这块内存标记为 “已分配”，并返回其地址。
>>-  **动态释放的实现:** 当一块内存不再需要时，可以将其释放回 “内存池”。 FreeRTOS 的堆管理器会将这块内存标记为 “空闲”，以便将来再次分配。
>
>**关键点：**
>
>* **没有真正的 “动态” 扩张:**  FreeRTOS 的堆大小是固定的，不会在运行时增加。
>* **动态管理的范围:**  FreeRTOS 的 “动态” 分配和释放只在 “内存池”  (即预先静态分配的内存块) 的范围内进行。

### 1、C 库的动态内存管理方法缺点

>为啥不用标准的 C 库自带的内存管理算法？
>
>- 占用大量的代码空间 不适合用在资源紧缺的嵌入式系统中
>- 没有线程安全的相关机制 
>- 运行有不确定性，每次调用这些函数时花费的时间可能都不相同
>- 内存碎片化
>- FreeRTOS 提供了动态内存管理的方法，并且针对不同的嵌入式系统，提供了多 种内存管理算法！

### 2、FreeRTOS内存管理算法

![image-20240825115627281](C:\Users\15924\AppData\Roaming\Typora\typora-user-images\image-20240825115627281.png)

> **heap_1：**只实现了pvPortMalloc，没有实现vPortFree；也就是说，它只能申请内存，无法释放内存。如果你的工程，创建好的任务、队列、信号量等都不需要被删除，那么可以使用heap_1内存管理算法

> **heap_2：**
>
> - 相比于 heap_1 内存管理算法， heap_2 内存管理算法使用最适应算法，并且支持释放内存
> - heap_2 内存管理算法并不能将相邻的空闲内存块合并成一个大的空闲内存块；因此  heap_2 内存管理算法不可避免地会产生内存碎片
> - 最适应算法根据需要申请的内存大小，找出最小的且能满足内存要求的内存块
> - 适用场景：频繁的创建和删除任务，且所创建的任务堆栈都相同，这类场景下Heap_2没有碎片化的问题

> **heap3：**调用C库函数malloc()和 free()，Heap_3中先暂停FreeRTOS的调度器，再去调用这些 函数，使用这种方法实现了线程安全

> **heap4：**heap_4 内存管理算法使用了首次适应算法，也支持内存的申请与释放，并且能够将空 闲且相邻的内存进行合并，从而减少内存碎片的现象。

> **heap_5：**heap_5 内存管理算法是在 heap_4 内存管理算法的基础上实现的，但是 heap_5 内存 管理算法在 heap_4 内存管理算法的基础上实现了管理多个非连续内存区域的能力（两块内存地址）

---

## 四、内存管理API函数介绍

> **注意：在一段内存没有被释放之前绝对不能再调用一次函数pvPortMalloc()为其再次分配内存，否则会导致内存泄露**

**1、初始化内存堆**

``

堆管理函数 :(用数组开辟空闲空间，**再提供管理的函数**)

1. 若不加头部，直接开辟空间，释放空间（就不知道有多大，并且空闲的**空间不好管理**）
2. 加头部，即再开辟空间+头部内容（开辟多大空间的信息），对空闲的空间进行管理，通过链表对不连续的空间进行关联,，空闲链表的结构体（空闲空间的大小+下一个空闲空间的地址）



**2、申请内存**

`void * pvPortMalloc( size_t  xWantedSize );`

**3、释放内存**

`void  vPortFree( void * pv );`

**4、获取当前空闲内存的大小**

`size_t  xPortGetFreeHeapSize( void );`