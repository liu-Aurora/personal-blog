

# LCD液晶显示屏

## 一、概述

>**液晶是一种介于固体和液体之间的特殊物质**，它是一种有机化合物，常态下呈液态，但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少，下图中液晶屏的结构就是绿色显示结构。利用这种原理，做出可控**红、绿、蓝光输出强度的显示结构，把三种显示结构组成一个显示单位，通过控制红绿蓝的强度，可以使该单位混合输出不同的色彩，这样的一个显示单位被称为像素。**

![image-20240910213857492](D:\markdown\其他中间件\assets\image-20240910213857492.png)	

**显示器的基本参数**

![image-20240910214048603](D:\markdown\其他中间件\assets\image-20240910214048603.png)	

**LCD简介**：Liquid Crystal Display，即液晶显示器，由：玻璃基板、背光、驱动IC等组成，全彩LCD，是一种全彩显示屏（RGB565、RGB888），可以显示各种颜色。

>- RGB 信号线的数量分别是5根，6根，5根，分别用于表示液晶屏一个像素点的红、绿、蓝颜色分量。使用红绿蓝颜色分量来表示颜色是一种通用的做法。
>- 常见的颜色表示会在“RGB”后面附带各个颜色分量值的数据位数，如 RGB565 表示红绿蓝的数据线数分别为 5、6、 5 根，一共为 16 个数据位，可表示 216 种颜色。

**显存：**

- 液晶屏中的每个像素点都是数据，在实际应用中需要把每个像素点的数据缓存起来，再传输给液晶屏，一般会使用 SRAM 或 SDRAM 性质的存储器，而这些专门用于存储显示数据的存储器，则被称为显存。

- 显存一般至少要能存储液晶屏的一帧(一页，也就是480*800个像素点)显示数据，如分辨率为 800x480 的液晶屏，使用 RGB565 格式显示，一帧显示数据大小为： 2x800x480=768000 字节。

- 一般来说，外置的液晶控制器会自带显存，而像 STM32F429 等集成液晶控制器的芯片可使用内部 SRAM 或外扩 SDRAM 用于显存空间。

## 二、ILI9341 液晶控制器简介

![image-20240910214850304](D:\markdown\其他中间件\assets\image-20240910214850304.png)	

- 该芯片最主核心部分是位于中间的 GRAM(Graphics RAM)，它就是显存。 GRAM 中每个存储单元都对应着液晶面板的一个像素点。它右侧的各种模块共同把 GRAM 存储单元的数据转化成液晶面板的控制信号，使像素点呈现特定的颜色，而像素点组合起来则成为一幅完整的图像。
- 框图的左上角为 ILI9341 的主要控制信号线和配置引脚，根据其不同状态设置可以使芯片工作在不同的模式，如每个像素点的位数是 6、 16 还是 18 位；可配置使用 SPI 接口、 8080 接口还是 RGB接口与 MCU 进行通讯。
- MCU 通过 SPI、 8080 接口或 RGB 接口与 ILI9341 进行通讯，从而访问它的控制寄存器 (CR)、地址计数器 (AC)、及 GRAM
- 在 GRAM 的左侧还有一个 LED 控制器 (LED Controller)。 LCD 为非发光性的显示装置，它需要借助背光源才能达到显示功能， LED 控制器就是用来控制液晶屏中的 LED 背光源。

 **液晶屏的信号线**：
ILI9341 控制器根据自身的 IM[3:0] 信号线电平决定它与 MCU 的通讯方式，它本身支持 SPI 及8080 通讯方式，本示例中液晶屏的 ILI9341 控制器在出厂前就已经按固定配置好 (内部已连接硬件电路)，它被配置为通过 8080 接口通讯，使用 16 根数据线的 RGB565 格式。

![image-20240910215953025](D:\markdown\其他中间件\assets\image-20240910215953025.png)

![image-20240910220042019](D:\markdown\其他中间件\assets\image-20240910220042019.png)

##  三、LCD驱动原理

### LCD驱动基本知识:

1. 8080时序，LCD驱动芯片一般使用8080时序控制，实现数据写入/读取
2. 初始化序列（数组），屏厂提供，用于初始化特定屏幕，不同屏幕厂家不完全相同！
3. 画点函数、读点函数（非必需），基于这两个函数可以实现各种绘图功能！

### **8080时序简介**

![image-20240910220501936](D:\markdown\其他中间件\assets\image-20240910220501936.png)

### **LCD驱动芯片指令**

![image-20240910220650609](D:\markdown\其他中间件\assets\image-20240910220650609.png)

**写GRAM指令（0X2C）**：发送该指令后，数据线变成16位，可以开始写入GRAM数据，支持地址自增

![image-20240918201833868](D:\markdown\其他中间件\assets\image-20240918201833868.png)



**读ID指令（0XD3）**

![image-20240910220919456](D:\markdown\其他中间件\assets\image-20240910220919456.png)

**访问控制指令（0X36）**

![image-20240910221007353](D:\markdown\其他中间件\assets\image-20240910221007353.png)

**MX、MY、MV扫描方向控制关系**

![image-20240910221044308](D:\markdown\其他中间件\assets\image-20240910221044308.png)

## 四、FMC驱动LCD

>通过FMC来模拟8080时序，来抽象底层通信协议，最终直接输入输出（FIFO）

**8080通信时序：1、直接用IO口模拟时序 2、通过配置stm32的外设实现硬件模拟时序**

###  **两种方法引脚对比**

![image-20240918135040449](D:\markdown\其他中间件\assets\image-20240918135040449.png)

>CPU 通过 AHB 总线与 FMC 进行通信，实现对外部存储器的访问和控制。AHB 总线提供了一种高性能、低延迟的连接方式，可以满足 FMC 对数据传输速度和实时性的要求

**AHB 总线的主要信号：**

- **HCLK**: AHB 总线的时钟信号。
- **HADDR[31:0]**: 地址总线，用于寻址 FMC 的寄存器。
- **HWRITE**: 写使能信号，指示 CPU 正在向 FMC 写入数据。
- **HREAD**: 读使能信号，指示 CPU 正在从 FMC 读取数据。
- **HWDATA[31:0]**: 数据总线，用于传输数据。
- **HREADY**: 等待信号，指示 FMC 是否准备好进行数据传输。
- **HRESP**: 响应信号，指示 FMC 对 CPU 请求的响应状态。

### FMC引脚实现

1、 片选CS ---- FMC_NE

![image-20240918142543406](D:\markdown\其他中间件\assets\image-20240918142543406.png)	

当 STM32 访问0x6C000000-0x6FFFFFFF 地址空间时，其实就是访问FSMC BANK1的第一块区域，**FSMC_NE1 引脚会自动设置为低电平**

- Bank1：0110-0000 0000-0000 0000-0000 0000-0000 ，即 60 00 00 00；

- Bank2：0110-0100 0000-0000 0000-0000 0000-0000 ，即 64 00 00 00；

- Bank3：0110-1000 0000-0000 0000-0000 0000-0000 ，即 68 00 00 00；

- Bank4：0110-1100 0000-0000 0000-0000 0000-0000 ，即 6c 00 00 00；

2、数据\命令FMC_A[X] --- RS 

> 对于FMC来讲，地址总线与数据总线是分开的，而8080时序是通过数据总线来描述地址的。
>
> 因此，对于模拟8080时序用不到地址总线，地址映射也没用，但8080时序差一个RS，来确定数据是命令\数据
>
> 即，写地址就是，确定RS是命令\数据

**如何地址总线，来表示RS**:

>1、在26个地址总线取一根用于表述RS
>
>>当FMC_A19为高电平时（即RS为高电平），FMC_D[15:0]被理解为数据。
>>当FMC_A19为低电平时（即RS为低电平），FMC_D[15:0]被理解为命令。
>
>2、拿到Bankx的地址，对应的26位都是0，该地址就表示  --- 命令
>
>>NEx(x=1…4)：0x6000 0000 + (0x400 0000 * (x - 1))
>
>3、将对应的RS的地址位，置1，FMC_Ay(y=0…24)： 2y x 2，对应位置1 --- 数据（为什么x2,看FMC地址映射）
>
>>FMC_Ay(y=0…24)： 2y x 2 

 
